; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: llc < %s -mtriple=xtensa | FileCheck %s

define void @xor_loop(ptr %a, ptr %b, i32 %n) {
; CHECK-LABEL: xor_loop:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    blti a4, 1, .LBB0_7
; CHECK-NEXT:  # %bb.1: # %for.body.preheader
; CHECK-NEXT:    movi.n a6, 0
; CHECK-NEXT:    addi.n a7, a4, -1
; CHECK-NEXT:    extui a5, a4, 0, 2
; CHECK-NEXT:    bltui a7, 3, .LBB0_4
; CHECK-NEXT:  # %bb.2: # %for.body.preheader.new
; CHECK-NEXT:    movi.n a7, -4
; CHECK-NEXT:    movi.n a6, 0
; CHECK-NEXT:    and a4, a4, a7
; CHECK-NEXT:  .LBB0_3: # %for.body
; CHECK-NEXT:    # =>This Inner Loop Header: Depth=1
; CHECK-NEXT:    add.n a7, a3, a6
; CHECK-NEXT:    add.n a9, a2, a6
; CHECK-NEXT:    l8ui a8, a7, 0
; CHECK-NEXT:    l8ui a10, a9, 0
; CHECK-NEXT:    addi.n a6, a6, 4
; CHECK-NEXT:    xor a8, a10, a8
; CHECK-NEXT:    s8i a8, a9, 0
; CHECK-NEXT:    l8ui a8, a7, 1
; CHECK-NEXT:    l8ui a10, a9, 1
; CHECK-NEXT:    xor a8, a10, a8
; CHECK-NEXT:    s8i a8, a9, 1
; CHECK-NEXT:    l8ui a8, a7, 2
; CHECK-NEXT:    l8ui a10, a9, 2
; CHECK-NEXT:    xor a8, a10, a8
; CHECK-NEXT:    s8i a8, a9, 2
; CHECK-NEXT:    l8ui a7, a7, 3
; CHECK-NEXT:    l8ui a8, a9, 3
; CHECK-NEXT:    xor a7, a8, a7
; CHECK-NEXT:    s8i a7, a9, 3
; CHECK-NEXT:    bne a4, a6, .LBB0_3
; CHECK-NEXT:  .LBB0_4: # %for.cond.cleanup.loopexit.unr-lcssa
; CHECK-NEXT:    beqz a5, .LBB0_7
; CHECK-NEXT:  # %bb.5: # %for.body.epil.preheader
; CHECK-NEXT:    add.n a2, a2, a6
; CHECK-NEXT:    add.n a3, a3, a6
; CHECK-NEXT:  .LBB0_6: # %for.body.epil
; CHECK-NEXT:    # =>This Inner Loop Header: Depth=1
; CHECK-NEXT:    l8ui a4, a3, 0
; CHECK-NEXT:    l8ui a6, a2, 0
; CHECK-NEXT:    addi.n a5, a5, -1
; CHECK-NEXT:    xor a4, a6, a4
; CHECK-NEXT:    s8i a4, a2, 0
; CHECK-NEXT:    addi.n a2, a2, 1
; CHECK-NEXT:    addi.n a3, a3, 1
; CHECK-NEXT:    bnez a5, .LBB0_6
; CHECK-NEXT:  .LBB0_7: # %for.cond.cleanup
; CHECK-NEXT:    ret.n
entry:
  %cmp8 = icmp sgt i32 %n, 0
  br i1 %cmp8, label %for.body.preheader, label %for.cond.cleanup

for.body.preheader:                               ; preds = %entry
  %0 = add i32 %n, -1
  %xtraiter = and i32 %n, 3
  %1 = icmp ult i32 %0, 3
  br i1 %1, label %for.cond.cleanup.loopexit.unr-lcssa, label %for.body.preheader.new

for.body.preheader.new:                           ; preds = %for.body.preheader
  %unroll_iter = and i32 %n, -4
  br label %for.body

for.cond.cleanup.loopexit.unr-lcssa:              ; preds = %for.body, %for.body.preheader
  %i.09.unr = phi i32 [ 0, %for.body.preheader ], [ %inc.3, %for.body ]
  %lcmp.mod.not = icmp eq i32 %xtraiter, 0
  br i1 %lcmp.mod.not, label %for.cond.cleanup, label %for.body.epil

for.body.epil:                                    ; preds = %for.cond.cleanup.loopexit.unr-lcssa, %for.body.epil
  %i.09.epil = phi i32 [ %inc.epil, %for.body.epil ], [ %i.09.unr, %for.cond.cleanup.loopexit.unr-lcssa ]
  %epil.iter = phi i32 [ %epil.iter.next, %for.body.epil ], [ 0, %for.cond.cleanup.loopexit.unr-lcssa ]
  %arrayidx.epil = getelementptr inbounds i8, ptr %b, i32 %i.09.epil
  %2 = load i8, ptr %arrayidx.epil, align 1
  %arrayidx1.epil = getelementptr inbounds i8, ptr %a, i32 %i.09.epil
  %3 = load i8, ptr %arrayidx1.epil, align 1
  %xor7.epil = xor i8 %3, %2
  store i8 %xor7.epil, ptr %arrayidx1.epil, align 1
  %inc.epil = add nuw nsw i32 %i.09.epil, 1
  %epil.iter.next = add i32 %epil.iter, 1
  %epil.iter.cmp.not = icmp eq i32 %epil.iter.next, %xtraiter
  br i1 %epil.iter.cmp.not, label %for.cond.cleanup, label %for.body.epil

for.cond.cleanup:                                 ; preds = %for.cond.cleanup.loopexit.unr-lcssa, %for.body.epil, %entry
  ret void

for.body:                                         ; preds = %for.body, %for.body.preheader.new
  %i.09 = phi i32 [ 0, %for.body.preheader.new ], [ %inc.3, %for.body ]
  %niter = phi i32 [ 0, %for.body.preheader.new ], [ %niter.next.3, %for.body ]
  %arrayidx = getelementptr inbounds i8, ptr %b, i32 %i.09
  %4 = load i8, ptr %arrayidx, align 1
  %arrayidx1 = getelementptr inbounds i8, ptr %a, i32 %i.09
  %5 = load i8, ptr %arrayidx1, align 1
  %xor7 = xor i8 %5, %4
  store i8 %xor7, ptr %arrayidx1, align 1
  %inc = or i32 %i.09, 1
  %arrayidx.1 = getelementptr inbounds i8, ptr %b, i32 %inc
  %6 = load i8, ptr %arrayidx.1, align 1
  %arrayidx1.1 = getelementptr inbounds i8, ptr %a, i32 %inc
  %7 = load i8, ptr %arrayidx1.1, align 1
  %xor7.1 = xor i8 %7, %6
  store i8 %xor7.1, ptr %arrayidx1.1, align 1
  %inc.1 = or i32 %i.09, 2
  %arrayidx.2 = getelementptr inbounds i8, ptr %b, i32 %inc.1
  %8 = load i8, ptr %arrayidx.2, align 1
  %arrayidx1.2 = getelementptr inbounds i8, ptr %a, i32 %inc.1
  %9 = load i8, ptr %arrayidx1.2, align 1
  %xor7.2 = xor i8 %9, %8
  store i8 %xor7.2, ptr %arrayidx1.2, align 1
  %inc.2 = or i32 %i.09, 3
  %arrayidx.3 = getelementptr inbounds i8, ptr %b, i32 %inc.2
  %10 = load i8, ptr %arrayidx.3, align 1
  %arrayidx1.3 = getelementptr inbounds i8, ptr %a, i32 %inc.2
  %11 = load i8, ptr %arrayidx1.3, align 1
  %xor7.3 = xor i8 %11, %10
  store i8 %xor7.3, ptr %arrayidx1.3, align 1
  %inc.3 = add nuw nsw i32 %i.09, 4
  %niter.next.3 = add i32 %niter, 4
  %niter.ncmp.3 = icmp eq i32 %niter.next.3, %unroll_iter
  br i1 %niter.ncmp.3, label %for.cond.cleanup.loopexit.unr-lcssa, label %for.body
}
