; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: llc < %s -mtriple=xtensa | FileCheck %s --check-prefix=OPT
; RUN: llc -O0 < %s -mtriple=xtensa | FileCheck %s --check-prefix=UNOPT

define i1 @and_i1(i1 %a, i1 %b) {
; OPT-LABEL: and_i1:
; OPT:       # %bb.0: # %entry
; OPT-NEXT:    and a2, a3, a2
; OPT-NEXT:    ret.n
;
; UNOPT-LABEL: and_i1:
; UNOPT:       # %bb.1: # %entry
; UNOPT-NEXT:    and a2, a3, a2
; UNOPT-NEXT:    ret.n
entry:
  %and = and i1 %b, %a
  ret i1 %and
}

define i1 @or_i1(i1 %a, i1 %b) {
; OPT-LABEL: or_i1:
; OPT:       # %bb.0: # %entry
; OPT-NEXT:    or a2, a3, a2
; OPT-NEXT:    ret.n
;
; UNOPT-LABEL: or_i1:
; UNOPT:       # %bb.1: # %entry
; UNOPT-NEXT:    or a2, a3, a2
; UNOPT-NEXT:    ret.n
entry:
  %or = or i1 %b, %a
  ret i1 %or
}

define i1 @xor_i1(i1 %a, i1 %b) {
; OPT-LABEL: xor_i1:
; OPT:       # %bb.0: # %entry
; OPT-NEXT:    xor a2, a3, a2
; OPT-NEXT:    ret.n
;
; UNOPT-LABEL: xor_i1:
; UNOPT:       # %bb.1: # %entry
; UNOPT-NEXT:    xor a2, a3, a2
; UNOPT-NEXT:    ret.n
entry:
  %xor = xor i1 %b, %a
  ret i1 %xor
}

define i8 @and_i8(i8 %a, i8 %b) {
; OPT-LABEL: and_i8:
; OPT:       # %bb.0: # %entry
; OPT-NEXT:    and a2, a3, a2
; OPT-NEXT:    ret.n
;
; UNOPT-LABEL: and_i8:
; UNOPT:       # %bb.1: # %entry
; UNOPT-NEXT:    and a2, a3, a2
; UNOPT-NEXT:    ret.n
entry:
  %and = and i8 %b, %a
  ret i8 %and
}

define i8 @or_i8(i8 %a, i8 %b) {
; OPT-LABEL: or_i8:
; OPT:       # %bb.0: # %entry
; OPT-NEXT:    or a2, a3, a2
; OPT-NEXT:    ret.n
;
; UNOPT-LABEL: or_i8:
; UNOPT:       # %bb.1: # %entry
; UNOPT-NEXT:    or a2, a3, a2
; UNOPT-NEXT:    ret.n
entry:
  %or = or i8 %b, %a
  ret i8 %or
}

define i8 @xor_i8(i8 %a, i8 %b) {
; OPT-LABEL: xor_i8:
; OPT:       # %bb.0: # %entry
; OPT-NEXT:    xor a2, a3, a2
; OPT-NEXT:    ret.n
;
; UNOPT-LABEL: xor_i8:
; UNOPT:       # %bb.1: # %entry
; UNOPT-NEXT:    xor a2, a3, a2
; UNOPT-NEXT:    ret.n
entry:
  %xor = xor i8 %b, %a
  ret i8 %xor
}

define i16 @and_i16(i16 %a, i16 %b) {
; OPT-LABEL: and_i16:
; OPT:       # %bb.0: # %entry
; OPT-NEXT:    and a2, a3, a2
; OPT-NEXT:    ret.n
;
; UNOPT-LABEL: and_i16:
; UNOPT:       # %bb.1: # %entry
; UNOPT-NEXT:    and a2, a3, a2
; UNOPT-NEXT:    ret.n
entry:
  %and = and i16 %b, %a
  ret i16 %and
}

define i16 @or_i16(i16 %a, i16 %b) {
; OPT-LABEL: or_i16:
; OPT:       # %bb.0: # %entry
; OPT-NEXT:    or a2, a3, a2
; OPT-NEXT:    ret.n
;
; UNOPT-LABEL: or_i16:
; UNOPT:       # %bb.1: # %entry
; UNOPT-NEXT:    or a2, a3, a2
; UNOPT-NEXT:    ret.n
entry:
  %or = or i16 %b, %a
  ret i16 %or
}

define i16 @xor_i16(i16 %a, i16 %b) {
; OPT-LABEL: xor_i16:
; OPT:       # %bb.0: # %entry
; OPT-NEXT:    xor a2, a3, a2
; OPT-NEXT:    ret.n
;
; UNOPT-LABEL: xor_i16:
; UNOPT:       # %bb.1: # %entry
; UNOPT-NEXT:    xor a2, a3, a2
; UNOPT-NEXT:    ret.n
entry:
  %xor = xor i16 %b, %a
  ret i16 %xor
}

define i32 @and_i32(i32 %a, i32 %b) {
; OPT-LABEL: and_i32:
; OPT:       # %bb.0: # %entry
; OPT-NEXT:    and a2, a3, a2
; OPT-NEXT:    ret.n
;
; UNOPT-LABEL: and_i32:
; UNOPT:       # %bb.1: # %entry
; UNOPT-NEXT:    and a2, a3, a2
; UNOPT-NEXT:    ret.n
entry:
  %and = and i32 %b, %a
  ret i32 %and
}

define i32 @or_i32(i32 %a, i32 %b) {
; OPT-LABEL: or_i32:
; OPT:       # %bb.0: # %entry
; OPT-NEXT:    or a2, a3, a2
; OPT-NEXT:    ret.n
;
; UNOPT-LABEL: or_i32:
; UNOPT:       # %bb.1: # %entry
; UNOPT-NEXT:    or a2, a3, a2
; UNOPT-NEXT:    ret.n
entry:
  %or = or i32 %b, %a
  ret i32 %or
}

define i32 @xor_i32(i32 %a, i32 %b) {
; OPT-LABEL: xor_i32:
; OPT:       # %bb.0: # %entry
; OPT-NEXT:    xor a2, a3, a2
; OPT-NEXT:    ret.n
;
; UNOPT-LABEL: xor_i32:
; UNOPT:       # %bb.1: # %entry
; UNOPT-NEXT:    xor a2, a3, a2
; UNOPT-NEXT:    ret.n
entry:
  %xor = xor i32 %b, %a
  ret i32 %xor
}

define i64 @and_i64(i64 %a, i64 %b) {
; OPT-LABEL: and_i64:
; OPT:       # %bb.0: # %entry
; OPT-NEXT:    and a2, a4, a2
; OPT-NEXT:    and a3, a5, a3
; OPT-NEXT:    ret.n
;
; UNOPT-LABEL: and_i64:
; UNOPT:       # %bb.1: # %entry
; UNOPT-NEXT:    and a2, a4, a2
; UNOPT-NEXT:    and a3, a5, a3
; UNOPT-NEXT:    ret.n
entry:
  %and = and i64 %b, %a
  ret i64 %and
}

define i64 @or_i64(i64 %a, i64 %b) {
; OPT-LABEL: or_i64:
; OPT:       # %bb.0: # %entry
; OPT-NEXT:    or a2, a4, a2
; OPT-NEXT:    or a3, a5, a3
; OPT-NEXT:    ret.n
;
; UNOPT-LABEL: or_i64:
; UNOPT:       # %bb.1: # %entry
; UNOPT-NEXT:    or a2, a4, a2
; UNOPT-NEXT:    or a3, a5, a3
; UNOPT-NEXT:    ret.n
entry:
  %or = or i64 %b, %a
  ret i64 %or
}

define i64 @xor_i64(i64 %a, i64 %b) {
; OPT-LABEL: xor_i64:
; OPT:       # %bb.0: # %entry
; OPT-NEXT:    xor a2, a4, a2
; OPT-NEXT:    xor a3, a5, a3
; OPT-NEXT:    ret.n
;
; UNOPT-LABEL: xor_i64:
; UNOPT:       # %bb.1: # %entry
; UNOPT-NEXT:    xor a2, a4, a2
; UNOPT-NEXT:    xor a3, a5, a3
; UNOPT-NEXT:    ret.n
entry:
  %xor = xor i64 %b, %a
  ret i64 %xor
}
