# NOTE: Assertions have been autogenerated by utils/update_mir_test_checks.py
# RUN: llc -O0 -mtriple=xtensa -run-pass=legalizer -verify-machineinstrs %s -o - | FileCheck %s
--- |
  ; ModuleID = 'mem_funcs.ll'
  source_filename = "mem_funcs.ll"
  target datalayout = "e-m:e-p:32:32-i64:64-n32-S128"
  target triple = "xtensa"

  ; Function Attrs: argmemonly nofree nounwind willreturn writeonly
  declare void @llvm.memset.p0.i32(ptr nocapture writeonly, i8, i32, i1 immarg) #0

  ; Function Attrs: argmemonly nofree nounwind willreturn
  declare void @llvm.memcpy.p0.p0.i32(ptr noalias nocapture writeonly, ptr noalias nocapture readonly, i32, i1 immarg) #1

  ; Function Attrs: argmemonly nofree nounwind willreturn
  declare void @llvm.memmove.p0.p0.i32(ptr nocapture writeonly, ptr nocapture readonly, i32, i1 immarg) #1

  define void @do_memset(ptr %p, i8 %val, i32 %len) {
    call void @llvm.memset.p0.i32(ptr %p, i8 %val, i32 %len, i1 false)
    ret void
  }

  define void @do_memcpy(ptr %dest, ptr %src, i32 %len) {
    call void @llvm.memcpy.p0.p0.i32(ptr %dest, ptr %src, i32 %len, i1 false)
    ret void
  }

  define void @do_memmove(ptr %dest, ptr %src, i32 %len) {
    call void @llvm.memmove.p0.p0.i32(ptr %dest, ptr %src, i32 %len, i1 false)
    ret void
  }

  attributes #0 = { argmemonly nofree nounwind willreturn writeonly }
  attributes #1 = { argmemonly nofree nounwind willreturn }

...
---
name:            do_memset
alignment:       4
exposesReturnsTwice: false
legalized:       false
regBankSelected: false
selected:        false
failedISel:      false
tracksRegLiveness: true
hasWinCFI:       false
callsEHReturn:   false
callsUnwindInit: false
hasEHCatchret:   false
hasEHScopes:     false
hasEHFunclets:   false
failsVerification: false
tracksDebugUserValues: false
registers:
  - { id: 0, class: _, preferred-register: '' }
  - { id: 1, class: _, preferred-register: '' }
  - { id: 2, class: _, preferred-register: '' }
  - { id: 3, class: _, preferred-register: '' }
liveins:
  - { reg: '$a2', virtual-reg: '' }
  - { reg: '$a3', virtual-reg: '' }
  - { reg: '$a4', virtual-reg: '' }
frameInfo:
  isFrameAddressTaken: false
  isReturnAddressTaken: false
  hasStackMap:     false
  hasPatchPoint:   false
  stackSize:       0
  offsetAdjustment: 0
  maxAlignment:    1
  adjustsStack:    false
  hasCalls:        false
  stackProtector:  ''
  functionContext: ''
  maxCallFrameSize: 4294967295
  cvBytesOfCalleeSavedRegisters: 0
  hasOpaqueSPAdjustment: false
  hasVAStart:      false
  hasMustTailInVarArgFunc: false
  hasTailCall:     false
  localFrameSize:  0
  savePoint:       ''
  restorePoint:    ''
fixedStack:      []
stack:           []
callSites:       []
debugValueSubstitutions: []
constants:       []
machineFunctionInfo: {}
body:             |
  bb.1 (%ir-block.0):
    liveins: $a2, $a3, $a4

    ; CHECK-LABEL: name: do_memset
    ; CHECK: liveins: $a2, $a3, $a4
    ; CHECK-NEXT: {{  $}}
    ; CHECK-NEXT: [[COPY:%[0-9]+]]:_(p0) = COPY $a2
    ; CHECK-NEXT: [[COPY1:%[0-9]+]]:_(s32) = COPY $a3
    ; CHECK-NEXT: [[COPY2:%[0-9]+]]:_(s32) = COPY $a4
    ; CHECK-NEXT: ADJCALLSTACKDOWN 0, 0, implicit-def $a1, implicit $a1
    ; CHECK-NEXT: $a2 = COPY [[COPY]](p0)
    ; CHECK-NEXT: $a3 = COPY [[COPY1]](s32)
    ; CHECK-NEXT: $a4 = COPY [[COPY2]](s32)
    ; CHECK-NEXT: CALL0 &memset, csr_xtensa_call0, implicit-def $a0, implicit $a2, implicit $a3, implicit $a4
    ; CHECK-NEXT: ADJCALLSTACKUP 0, 0, implicit-def $a1, implicit $a1
    ; CHECK-NEXT: RETN implicit $a0
    %0:_(p0) = COPY $a2
    %3:_(s32) = COPY $a3
    %1:_(s8) = G_TRUNC %3(s32)
    %2:_(s32) = COPY $a4
    G_MEMSET %0(p0), %1(s8), %2(s32), 0 :: (store (s8) into %ir.p)
    RETN implicit $a0

...
---
name:            do_memcpy
alignment:       4
exposesReturnsTwice: false
legalized:       false
regBankSelected: false
selected:        false
failedISel:      false
tracksRegLiveness: true
hasWinCFI:       false
callsEHReturn:   false
callsUnwindInit: false
hasEHCatchret:   false
hasEHScopes:     false
hasEHFunclets:   false
failsVerification: false
tracksDebugUserValues: false
registers:
  - { id: 0, class: _, preferred-register: '' }
  - { id: 1, class: _, preferred-register: '' }
  - { id: 2, class: _, preferred-register: '' }
liveins:
  - { reg: '$a2', virtual-reg: '' }
  - { reg: '$a3', virtual-reg: '' }
  - { reg: '$a4', virtual-reg: '' }
frameInfo:
  isFrameAddressTaken: false
  isReturnAddressTaken: false
  hasStackMap:     false
  hasPatchPoint:   false
  stackSize:       0
  offsetAdjustment: 0
  maxAlignment:    1
  adjustsStack:    false
  hasCalls:        false
  stackProtector:  ''
  functionContext: ''
  maxCallFrameSize: 4294967295
  cvBytesOfCalleeSavedRegisters: 0
  hasOpaqueSPAdjustment: false
  hasVAStart:      false
  hasMustTailInVarArgFunc: false
  hasTailCall:     false
  localFrameSize:  0
  savePoint:       ''
  restorePoint:    ''
fixedStack:      []
stack:           []
callSites:       []
debugValueSubstitutions: []
constants:       []
machineFunctionInfo: {}
body:             |
  bb.1 (%ir-block.0):
    liveins: $a2, $a3, $a4

    ; CHECK-LABEL: name: do_memcpy
    ; CHECK: liveins: $a2, $a3, $a4
    ; CHECK-NEXT: {{  $}}
    ; CHECK-NEXT: [[COPY:%[0-9]+]]:_(p0) = COPY $a2
    ; CHECK-NEXT: [[COPY1:%[0-9]+]]:_(p0) = COPY $a3
    ; CHECK-NEXT: [[COPY2:%[0-9]+]]:_(s32) = COPY $a4
    ; CHECK-NEXT: ADJCALLSTACKDOWN 0, 0, implicit-def $a1, implicit $a1
    ; CHECK-NEXT: $a2 = COPY [[COPY]](p0)
    ; CHECK-NEXT: $a3 = COPY [[COPY1]](p0)
    ; CHECK-NEXT: $a4 = COPY [[COPY2]](s32)
    ; CHECK-NEXT: CALL0 &memcpy, csr_xtensa_call0, implicit-def $a0, implicit $a2, implicit $a3, implicit $a4
    ; CHECK-NEXT: ADJCALLSTACKUP 0, 0, implicit-def $a1, implicit $a1
    ; CHECK-NEXT: RETN implicit $a0
    %0:_(p0) = COPY $a2
    %1:_(p0) = COPY $a3
    %2:_(s32) = COPY $a4
    G_MEMCPY %0(p0), %1(p0), %2(s32), 0 :: (store (s8) into %ir.dest), (load (s8) from %ir.src)
    RETN implicit $a0

...
---
name:            do_memmove
alignment:       4
exposesReturnsTwice: false
legalized:       false
regBankSelected: false
selected:        false
failedISel:      false
tracksRegLiveness: true
hasWinCFI:       false
callsEHReturn:   false
callsUnwindInit: false
hasEHCatchret:   false
hasEHScopes:     false
hasEHFunclets:   false
failsVerification: false
tracksDebugUserValues: false
registers:
  - { id: 0, class: _, preferred-register: '' }
  - { id: 1, class: _, preferred-register: '' }
  - { id: 2, class: _, preferred-register: '' }
liveins:
  - { reg: '$a2', virtual-reg: '' }
  - { reg: '$a3', virtual-reg: '' }
  - { reg: '$a4', virtual-reg: '' }
frameInfo:
  isFrameAddressTaken: false
  isReturnAddressTaken: false
  hasStackMap:     false
  hasPatchPoint:   false
  stackSize:       0
  offsetAdjustment: 0
  maxAlignment:    1
  adjustsStack:    false
  hasCalls:        false
  stackProtector:  ''
  functionContext: ''
  maxCallFrameSize: 4294967295
  cvBytesOfCalleeSavedRegisters: 0
  hasOpaqueSPAdjustment: false
  hasVAStart:      false
  hasMustTailInVarArgFunc: false
  hasTailCall:     false
  localFrameSize:  0
  savePoint:       ''
  restorePoint:    ''
fixedStack:      []
stack:           []
callSites:       []
debugValueSubstitutions: []
constants:       []
machineFunctionInfo: {}
body:             |
  bb.1 (%ir-block.0):
    liveins: $a2, $a3, $a4

    ; CHECK-LABEL: name: do_memmove
    ; CHECK: liveins: $a2, $a3, $a4
    ; CHECK-NEXT: {{  $}}
    ; CHECK-NEXT: [[COPY:%[0-9]+]]:_(p0) = COPY $a2
    ; CHECK-NEXT: [[COPY1:%[0-9]+]]:_(p0) = COPY $a3
    ; CHECK-NEXT: [[COPY2:%[0-9]+]]:_(s32) = COPY $a4
    ; CHECK-NEXT: ADJCALLSTACKDOWN 0, 0, implicit-def $a1, implicit $a1
    ; CHECK-NEXT: $a2 = COPY [[COPY]](p0)
    ; CHECK-NEXT: $a3 = COPY [[COPY1]](p0)
    ; CHECK-NEXT: $a4 = COPY [[COPY2]](s32)
    ; CHECK-NEXT: CALL0 &memmove, csr_xtensa_call0, implicit-def $a0, implicit $a2, implicit $a3, implicit $a4
    ; CHECK-NEXT: ADJCALLSTACKUP 0, 0, implicit-def $a1, implicit $a1
    ; CHECK-NEXT: RETN implicit $a0
    %0:_(p0) = COPY $a2
    %1:_(p0) = COPY $a3
    %2:_(s32) = COPY $a4
    G_MEMMOVE %0(p0), %1(p0), %2(s32), 0 :: (store (s8) into %ir.dest), (load (s8) from %ir.src)
    RETN implicit $a0

...
