; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; RUN: opt < %s -loop-reduce -S | FileCheck %s

target datalayout = "e-m:e-p:32:32-i64:64-n32-S128"
target triple = "xtensa"

; Test `XtensaTargetLowering::isLegalAddressingMode` by making sure that LSR
; doesn't introduce negative pointer offsets. It may attempt to do this if it
; thinks that the offsets can be folded into neighboring loads and stores.

define dso_local void @xor_loop(ptr nocapture noundef %a, ptr nocapture noundef readonly %b, i32 noundef %n) {
; CHECK-LABEL: @xor_loop(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[CMP8:%.*]] = icmp sgt i32 [[N:%.*]], 0
; CHECK-NEXT:    br i1 [[CMP8]], label [[FOR_BODY_PREHEADER:%.*]], label [[FOR_COND_CLEANUP:%.*]]
; CHECK:       for.body.preheader:
; CHECK-NEXT:    [[TMP0:%.*]] = add i32 [[N]], -1
; CHECK-NEXT:    [[XTRAITER:%.*]] = and i32 [[N]], 3
; CHECK-NEXT:    [[TMP1:%.*]] = icmp ult i32 [[TMP0]], 3
; CHECK-NEXT:    br i1 [[TMP1]], label [[FOR_COND_CLEANUP_LOOPEXIT_UNR_LCSSA:%.*]], label [[FOR_BODY_PREHEADER_NEW:%.*]]
; CHECK:       for.body.preheader.new:
; CHECK-NEXT:    [[UNROLL_ITER:%.*]] = and i32 [[N]], -4
; CHECK-NEXT:    br label [[FOR_BODY:%.*]]
; CHECK:       for.cond.cleanup.loopexit.unr-lcssa.loopexit:
; CHECK-NEXT:    br label [[FOR_COND_CLEANUP_LOOPEXIT_UNR_LCSSA]]
; CHECK:       for.cond.cleanup.loopexit.unr-lcssa:
; CHECK-NEXT:    [[I_09_UNR:%.*]] = phi i32 [ 0, [[FOR_BODY_PREHEADER]] ], [ [[INC_3:%.*]], [[FOR_COND_CLEANUP_LOOPEXIT_UNR_LCSSA_LOOPEXIT:%.*]] ]
; CHECK-NEXT:    [[LCMP_MOD_NOT:%.*]] = icmp eq i32 [[XTRAITER]], 0
; CHECK-NEXT:    br i1 [[LCMP_MOD_NOT]], label [[FOR_COND_CLEANUP]], label [[FOR_BODY_EPIL_PREHEADER:%.*]]
; CHECK:       for.body.epil.preheader:
; CHECK-NEXT:    [[UGLYGEP:%.*]] = getelementptr i8, ptr [[A:%.*]], i32 [[I_09_UNR]]
; CHECK-NEXT:    [[UGLYGEP2:%.*]] = getelementptr i8, ptr [[B:%.*]], i32 [[I_09_UNR]]
; CHECK-NEXT:    br label [[FOR_BODY_EPIL:%.*]]
; CHECK:       for.body.epil:
; CHECK-NEXT:    [[LSR_IV5:%.*]] = phi i32 [ [[XTRAITER]], [[FOR_BODY_EPIL_PREHEADER]] ], [ [[LSR_IV_NEXT:%.*]], [[FOR_BODY_EPIL]] ]
; CHECK-NEXT:    [[LSR_IV3:%.*]] = phi ptr [ [[UGLYGEP2]], [[FOR_BODY_EPIL_PREHEADER]] ], [ [[UGLYGEP4:%.*]], [[FOR_BODY_EPIL]] ]
; CHECK-NEXT:    [[LSR_IV:%.*]] = phi ptr [ [[UGLYGEP]], [[FOR_BODY_EPIL_PREHEADER]] ], [ [[UGLYGEP1:%.*]], [[FOR_BODY_EPIL]] ]
; CHECK-NEXT:    [[TMP2:%.*]] = load i8, ptr [[LSR_IV3]], align 1
; CHECK-NEXT:    [[TMP3:%.*]] = load i8, ptr [[LSR_IV]], align 1
; CHECK-NEXT:    [[XOR7_EPIL:%.*]] = xor i8 [[TMP3]], [[TMP2]]
; CHECK-NEXT:    store i8 [[XOR7_EPIL]], ptr [[LSR_IV]], align 1
; CHECK-NEXT:    [[UGLYGEP1]] = getelementptr i8, ptr [[LSR_IV]], i32 1
; CHECK-NEXT:    [[UGLYGEP4]] = getelementptr i8, ptr [[LSR_IV3]], i32 1
; CHECK-NEXT:    [[LSR_IV_NEXT]] = add nsw i32 [[LSR_IV5]], -1
; CHECK-NEXT:    [[EPIL_ITER_CMP_NOT:%.*]] = icmp eq i32 [[LSR_IV_NEXT]], 0
; CHECK-NEXT:    br i1 [[EPIL_ITER_CMP_NOT]], label [[FOR_COND_CLEANUP_LOOPEXIT:%.*]], label [[FOR_BODY_EPIL]]
; CHECK:       for.cond.cleanup.loopexit:
; CHECK-NEXT:    br label [[FOR_COND_CLEANUP]]
; CHECK:       for.cond.cleanup:
; CHECK-NEXT:    ret void
; CHECK:       for.body:
; CHECK-NEXT:    [[I_09:%.*]] = phi i32 [ 0, [[FOR_BODY_PREHEADER_NEW]] ], [ [[INC_3]], [[FOR_BODY]] ]
; CHECK-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds i8, ptr [[B]], i32 [[I_09]]
; CHECK-NEXT:    [[TMP4:%.*]] = load i8, ptr [[ARRAYIDX]], align 1
; CHECK-NEXT:    [[ARRAYIDX1:%.*]] = getelementptr inbounds i8, ptr [[A]], i32 [[I_09]]
; CHECK-NEXT:    [[TMP5:%.*]] = load i8, ptr [[ARRAYIDX1]], align 1
; CHECK-NEXT:    [[XOR7:%.*]] = xor i8 [[TMP5]], [[TMP4]]
; CHECK-NEXT:    store i8 [[XOR7]], ptr [[ARRAYIDX1]], align 1
; CHECK-NEXT:    [[UGLYGEP16:%.*]] = getelementptr i8, ptr [[B]], i32 [[I_09]]
; CHECK-NEXT:    [[UGLYGEP17:%.*]] = getelementptr i8, ptr [[UGLYGEP16]], i32 1
; CHECK-NEXT:    [[TMP6:%.*]] = load i8, ptr [[UGLYGEP17]], align 1
; CHECK-NEXT:    [[UGLYGEP14:%.*]] = getelementptr i8, ptr [[A]], i32 [[I_09]]
; CHECK-NEXT:    [[UGLYGEP15:%.*]] = getelementptr i8, ptr [[UGLYGEP14]], i32 1
; CHECK-NEXT:    [[TMP7:%.*]] = load i8, ptr [[UGLYGEP15]], align 1
; CHECK-NEXT:    [[XOR7_1:%.*]] = xor i8 [[TMP7]], [[TMP6]]
; CHECK-NEXT:    store i8 [[XOR7_1]], ptr [[UGLYGEP15]], align 1
; CHECK-NEXT:    [[UGLYGEP12:%.*]] = getelementptr i8, ptr [[B]], i32 [[I_09]]
; CHECK-NEXT:    [[UGLYGEP13:%.*]] = getelementptr i8, ptr [[UGLYGEP12]], i32 2
; CHECK-NEXT:    [[TMP8:%.*]] = load i8, ptr [[UGLYGEP13]], align 1
; CHECK-NEXT:    [[UGLYGEP10:%.*]] = getelementptr i8, ptr [[A]], i32 [[I_09]]
; CHECK-NEXT:    [[UGLYGEP11:%.*]] = getelementptr i8, ptr [[UGLYGEP10]], i32 2
; CHECK-NEXT:    [[TMP9:%.*]] = load i8, ptr [[UGLYGEP11]], align 1
; CHECK-NEXT:    [[XOR7_2:%.*]] = xor i8 [[TMP9]], [[TMP8]]
; CHECK-NEXT:    store i8 [[XOR7_2]], ptr [[UGLYGEP11]], align 1
; CHECK-NEXT:    [[UGLYGEP8:%.*]] = getelementptr i8, ptr [[B]], i32 [[I_09]]
; CHECK-NEXT:    [[UGLYGEP9:%.*]] = getelementptr i8, ptr [[UGLYGEP8]], i32 3
; CHECK-NEXT:    [[TMP10:%.*]] = load i8, ptr [[UGLYGEP9]], align 1
; CHECK-NEXT:    [[UGLYGEP6:%.*]] = getelementptr i8, ptr [[A]], i32 [[I_09]]
; CHECK-NEXT:    [[UGLYGEP7:%.*]] = getelementptr i8, ptr [[UGLYGEP6]], i32 3
; CHECK-NEXT:    [[TMP11:%.*]] = load i8, ptr [[UGLYGEP7]], align 1
; CHECK-NEXT:    [[XOR7_3:%.*]] = xor i8 [[TMP11]], [[TMP10]]
; CHECK-NEXT:    store i8 [[XOR7_3]], ptr [[UGLYGEP7]], align 1
; CHECK-NEXT:    [[INC_3]] = add nuw i32 [[I_09]], 4
; CHECK-NEXT:    [[NITER_NCMP_3:%.*]] = icmp eq i32 [[UNROLL_ITER]], [[INC_3]]
; CHECK-NEXT:    br i1 [[NITER_NCMP_3]], label [[FOR_COND_CLEANUP_LOOPEXIT_UNR_LCSSA_LOOPEXIT]], label [[FOR_BODY]]
;
entry:
  %cmp8 = icmp sgt i32 %n, 0
  br i1 %cmp8, label %for.body.preheader, label %for.cond.cleanup

for.body.preheader:                               ; preds = %entry
  %0 = add i32 %n, -1
  %xtraiter = and i32 %n, 3
  %1 = icmp ult i32 %0, 3
  br i1 %1, label %for.cond.cleanup.loopexit.unr-lcssa, label %for.body.preheader.new

for.body.preheader.new:                           ; preds = %for.body.preheader
  %unroll_iter = and i32 %n, -4
  br label %for.body

for.cond.cleanup.loopexit.unr-lcssa:              ; preds = %for.body, %for.body.preheader
  %i.09.unr = phi i32 [ 0, %for.body.preheader ], [ %inc.3, %for.body ]
  %lcmp.mod.not = icmp eq i32 %xtraiter, 0
  br i1 %lcmp.mod.not, label %for.cond.cleanup, label %for.body.epil

for.body.epil:                                    ; preds = %for.cond.cleanup.loopexit.unr-lcssa, %for.body.epil
  %i.09.epil = phi i32 [ %inc.epil, %for.body.epil ], [ %i.09.unr, %for.cond.cleanup.loopexit.unr-lcssa ]
  %epil.iter = phi i32 [ %epil.iter.next, %for.body.epil ], [ 0, %for.cond.cleanup.loopexit.unr-lcssa ]
  %arrayidx.epil = getelementptr inbounds i8, ptr %b, i32 %i.09.epil
  %2 = load i8, ptr %arrayidx.epil, align 1
  %arrayidx1.epil = getelementptr inbounds i8, ptr %a, i32 %i.09.epil
  %3 = load i8, ptr %arrayidx1.epil, align 1
  %xor7.epil = xor i8 %3, %2
  store i8 %xor7.epil, ptr %arrayidx1.epil, align 1
  %inc.epil = add nuw nsw i32 %i.09.epil, 1
  %epil.iter.next = add i32 %epil.iter, 1
  %epil.iter.cmp.not = icmp eq i32 %epil.iter.next, %xtraiter
  br i1 %epil.iter.cmp.not, label %for.cond.cleanup, label %for.body.epil

for.cond.cleanup:                                 ; preds = %for.cond.cleanup.loopexit.unr-lcssa, %for.body.epil, %entry
  ret void

for.body:                                         ; preds = %for.body, %for.body.preheader.new
  %i.09 = phi i32 [ 0, %for.body.preheader.new ], [ %inc.3, %for.body ]
  %niter = phi i32 [ 0, %for.body.preheader.new ], [ %niter.next.3, %for.body ]
  %arrayidx = getelementptr inbounds i8, ptr %b, i32 %i.09
  %4 = load i8, ptr %arrayidx, align 1
  %arrayidx1 = getelementptr inbounds i8, ptr %a, i32 %i.09
  %5 = load i8, ptr %arrayidx1, align 1
  %xor7 = xor i8 %5, %4
  store i8 %xor7, ptr %arrayidx1, align 1
  %inc = or i32 %i.09, 1
  %arrayidx.1 = getelementptr inbounds i8, ptr %b, i32 %inc
  %6 = load i8, ptr %arrayidx.1, align 1
  %arrayidx1.1 = getelementptr inbounds i8, ptr %a, i32 %inc
  %7 = load i8, ptr %arrayidx1.1, align 1
  %xor7.1 = xor i8 %7, %6
  store i8 %xor7.1, ptr %arrayidx1.1, align 1
  %inc.1 = or i32 %i.09, 2
  %arrayidx.2 = getelementptr inbounds i8, ptr %b, i32 %inc.1
  %8 = load i8, ptr %arrayidx.2, align 1
  %arrayidx1.2 = getelementptr inbounds i8, ptr %a, i32 %inc.1
  %9 = load i8, ptr %arrayidx1.2, align 1
  %xor7.2 = xor i8 %9, %8
  store i8 %xor7.2, ptr %arrayidx1.2, align 1
  %inc.2 = or i32 %i.09, 3
  %arrayidx.3 = getelementptr inbounds i8, ptr %b, i32 %inc.2
  %10 = load i8, ptr %arrayidx.3, align 1
  %arrayidx1.3 = getelementptr inbounds i8, ptr %a, i32 %inc.2
  %11 = load i8, ptr %arrayidx1.3, align 1
  %xor7.3 = xor i8 %11, %10
  store i8 %xor7.3, ptr %arrayidx1.3, align 1
  %inc.3 = add nuw nsw i32 %i.09, 4
  %niter.next.3 = add i32 %niter, 4
  %niter.ncmp.3 = icmp eq i32 %niter.next.3, %unroll_iter
  br i1 %niter.ncmp.3, label %for.cond.cleanup.loopexit.unr-lcssa, label %for.body
}
