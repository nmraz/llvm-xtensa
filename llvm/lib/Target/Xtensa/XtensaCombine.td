include "llvm/Target/GlobalISel/Combine.td"


def left_identity_zero : GICombineRule<
  (defs root:$root),
  (match (wip_match_opcode G_ADD, G_OR, G_XOR):$root,
    [{ return Helper.matchConstantOp(${root}->getOperand(1), 0); }]),
  (apply [{ return Helper.replaceSingleDefInstWithOperand(*${root}, 2); }])
>;

def icmp_pow2_mask : GICombineRule<
  (defs root:$root, build_fn_matchinfo:$matchinfo),
  (match (wip_match_opcode G_ICMP):$root,
    [{ return matchICmpPow2Mask(MRI, *${root}, ${matchinfo}); }]),
  (apply [{ Helper.applyBuildFn(*${root}, ${matchinfo}); }])
>;

// Fold (xor (xor a, C), C) -> a
def repeated_xor_const : GICombineRule<
  (defs root:$root, register_matchinfo:$matchinfo),
  (match (wip_match_opcode G_XOR):$root,
    [{ return matchRepeatedXorConst(Helper, MRI, *${root}, ${matchinfo}); }]),
  (apply [{ applyRepeatedXorConst(Helper, MRI, *${root}, ${matchinfo}); }])
>;

def fold_expensive_icmp : GICombineRule<
  (defs root:$root, build_fn_matchinfo:$matchinfo),
  (match (wip_match_opcode G_ADD, G_AND, G_MUL, G_OR, G_SUB, G_XOR):$root,
    [{ return matchExpensiveICmpOp(MRI, *${root}, ${matchinfo}); }]),
  (apply [{ Helper.applyBuildFn(*${root}, ${matchinfo}); }])
>;


// Special rule for O0 to get rid of a lot of the cruft generated by the
// legalizer and enable branches to be selected without monstrous overhead.
// When optimizations are enabled, this is handled by the more powerful
// `redundant_and` combine.
def icmp_and_one : GICombineRule<
  (defs root:$root, register_matchinfo:$matchinfo),
  (match (wip_match_opcode G_AND):$root,
    [{ return matchICmpAndOne(MRI, *${root}, ${matchinfo}); }]),
  (apply [{ applyICmpAndOne(Helper, MRI, *${root}, ${matchinfo}); }])
>;


def set_sar_lowering_info : GIDefMatchData<"SetSarLoweringInfo">;
def int32_matchinfo : GIDefMatchData<"int32_t">;

def lower_set_sar_inrange : GICombineRule<
  (defs root:$root, set_sar_lowering_info:$matchinfo),
  (match (wip_match_opcode G_XTENSA_SSR_INRANGE, G_XTENSA_SSL_INRANGE):$root,
    [{ return matchLowerSetSarInrange(MRI, *Helper.getKnownBits(), *${root}, ${matchinfo}); }]),
  (apply [{ applySetSarLowering(Helper, MRI, *${root}, ${matchinfo}); }])
>;

def set_sar_masked_redundant_and : GICombineRule<
  (defs root:$root, register_matchinfo:$matchinfo),
  (match (wip_match_opcode G_XTENSA_SSR_MASKED, G_XTENSA_SSL_MASKED):$root,
    [{ return matchSetSarMaskedRedundantAnd(MRI, *Helper.getKnownBits(), *${root}, ${matchinfo}); }]),
  (apply [{ Helper.replaceRegOpWith(MRI, ${root}->getOperand(0), ${matchinfo}); }])
>;

def invert_set_sar_masked : GICombineRule<
  (defs root:$root, set_sar_lowering_info:$matchinfo),
  (match (wip_match_opcode G_XTENSA_SSR_MASKED, G_XTENSA_SSL_MASKED):$root,
    [{ return matchInvSetSarMasked(MRI, *Helper.getKnownBits(), *${root}, ${matchinfo}); }]),
  (apply [{ applySetSarLowering(Helper, MRI, *${root}, ${matchinfo}); }])
>;

def set_sar_masked_const_add_sub_left : GICombineRule<
  (defs root:$root, build_fn_matchinfo:$matchinfo),
  (match (wip_match_opcode G_XTENSA_SSR_MASKED, G_XTENSA_SSL_MASKED):$root,
    [{ return matchSetSarMaskedConstAddSub(Helper, MRI, *${root}, 1, ${matchinfo}); }]),
  (apply [{ Helper.applyBuildFnNoErase(*${root}, ${matchinfo}); }])
>;

def set_sar_masked_const_add_sub_right : GICombineRule<
  (defs root:$root, build_fn_matchinfo:$matchinfo),
  (match (wip_match_opcode G_XTENSA_SSR_MASKED, G_XTENSA_SSL_MASKED):$root,
    [{ return matchSetSarMaskedConstAddSub(Helper, MRI, *${root}, 2, ${matchinfo}); }]),
  (apply [{ Helper.applyBuildFnNoErase(*${root}, ${matchinfo}); }])
>;

def ssr_masked_const : GICombineRule<
  (defs root:$root, int32_matchinfo:$matchinfo),
  (match (wip_match_opcode G_XTENSA_SSR_MASKED):$root,
    [{ return matchUnmaskedConst(MRI, *${root}, ${matchinfo}); }]),
  (apply [{ replaceOperandWithConstant(Helper, MRI, B, ${root}->getOperand(0), ${matchinfo}); }])
>;

def ssl_masked_const : GICombineRule<
  (defs root:$root, int32_matchinfo:$matchinfo),
  (match (wip_match_opcode G_XTENSA_SSL_MASKED):$root,
    [{ return matchSSLMaskedConst(MRI, *${root}, ${matchinfo}); }]),
  (apply [{ applySSLMaskedConst(Helper, MRI, B, *${root}, ${matchinfo}); }])
>;

// Based on `all_combines`, with irrelevant (vector/floating-point) combines
// removed. Also removed is `xor_of_and_with_same_reg`, since xtensa does not
// have a dedicated `not` instruction, making the original version less
// expensive.
def xtensa_generic_combines : GICombineGroup<[trivial_combines,
    combines_for_extload,
    undef_combines, identity_combines, phi_combines,
    simplify_add_to_sub, hoist_logic_op_with_same_opcode_hands,
    reassocs, ptr_add_immed_chain,
    shl_ashr_to_sext_inreg, sext_inreg_of_load,
    select_combines,
    known_bits_simplifications, ext_ext_fold,
    not_cmp_fold, opt_brcond_by_inverting_cond,
    const_combines, ptr_add_with_zero,
    shift_immed_chain, shift_of_shifted_logic_chain, load_or_combine,
    truncstore_merge, funnel_shift_combines,
    constant_fold,
    intdiv_combines, mulh_combines,
    and_or_disjoint_mask]>;

def XtensaPostLegalizerCombinerHelper : GICombinerHelper<
  "XtensaGenPostLegalizerCombinerHelper",
  [xtensa_generic_combines,
   // Xtensa-specific
   fold_binop_into_select, left_identity_zero, icmp_pow2_mask,
   repeated_xor_const, fold_expensive_icmp]> {
  let DisableRuleOption = "xtensapostlegalizercombiner-disable-rule";
}

def XtensaO0PostLegalizerCombinerHelper : GICombinerHelper<
  "XtensaGenO0PostLegalizerCombinerHelper",
  [optnone_combines, icmp_and_one]> {
  let DisableRuleOption = "xtensao0postlegalizercombiner-disable-rule";
}

def XtensaShiftCombinerHelper : GICombinerHelper<
  "XtensaGenShiftCombinerHelper",
  [lower_set_sar_inrange, set_sar_masked_redundant_and, invert_set_sar_masked,
   set_sar_masked_const_add_sub_left, set_sar_masked_const_add_sub_right,
   ssr_masked_const, ssl_masked_const, right_identity_zero, left_identity_zero]> {
  let DisableRuleOption = "xtensashiftcombiner-disable-rule";
}
